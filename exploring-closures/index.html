<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Exploring Closures | My New Hugo Site</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example const secret = msg => () => msg;. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36
The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.
Note: In the following example I&rsquo;m missing the main point!">
<meta name=generator content="Hugo 0.91.2">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Exploring Closures">
<meta property="og:description" content="I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example const secret = msg => () => msg;. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36
The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.
Note: In the following example I&rsquo;m missing the main point!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://claytron5000.github.io/exploring-closures/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2019-04-19T20:34:07+00:00">
<meta property="article:modified_time" content="2019-04-19T20:34:07+00:00">
<meta itemprop=name content="Exploring Closures">
<meta itemprop=description content="I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example const secret = msg => () => msg;. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36
The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.
Note: In the following example I&rsquo;m missing the main point!"><meta itemprop=datePublished content="2019-04-19T20:34:07+00:00">
<meta itemprop=dateModified content="2019-04-19T20:34:07+00:00">
<meta itemprop=wordCount content="1138">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Exploring Closures">
<meta name=twitter:description content="I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example const secret = msg => () => msg;. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36
The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.
Note: In the following example I&rsquo;m missing the main point!">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
My New Hugo Site
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Exploring Closures</h1>
<p class=tracked>
By <strong>
Clayton Salem
</strong>
</p>
<time class="f6 mv4 dib tracked" datetime=2019-04-19T20:34:07Z>April 19, 2019</time>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example <code>const secret = msg => () => msg;</code>. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: <a href=https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36>https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36</a></p>
<p>The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.</p>
<p>Note: In the following example <strong>I&rsquo;m missing the main point!</strong>, which is &ldquo;Data privacy is an essential property that helps us program to an interface, not an implementation.&rdquo; What follows is a rather silly <em>implmentation</em> using data privacy to hide secret values, not create an interface to be extended and built upon later. Most of these posts and side-projects are about playing and learning, so I&rsquo;m excusing myself to do just that. (Update to this at the bottom.)</p>
<p>The application I build here is a list of &ldquo;users&rdquo;, their names and pictures can be accessed by anyone. However, their &ldquo;secrets&rdquo; are accessible only by making a request with the corresponding <code>accessToken</code>. Here&rsquo;s an example user:</p>
<pre tabindex=0><code>{
    jimmy: {
        secret: &quot;I eat cat food&quot;,
        accessToken: &quot;fdsasaf&quot;
    }
}
</code></pre><p>I&rsquo;m keying the object on the name for convenience.</p>
<p>In order to get the <code>accessToken</code> we need to send a password, which then returns a token, that token can then be used to get a list of <code>accessTokens</code> for each of the other users.</p>
<p>In this whole process we want to keep our password, our token, and our list of tokens out of the global scope, and not saved to any external source (say session storage). This is where our closure comes into play.</p>
<p>Note: instead of creating a real server I&rsquo;ve basically added another js file to the page. In this file is both the secret data, some page rendering, and some mocked <code>fetch</code> functions we can use to pretend we&rsquo;re calling to a server.</p>
<pre tabindex=0><code>// Page rendery server code
const users = {
    jimmy: {
        secret: &quot;I just want to be alone.&quot;,
        accessToken: &quot;l;kj&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/9.jpg&quot;
    },
    susy: {
        secret: &quot;I eat fourteen bananas every day.&quot;,
        accessToken: &quot;fdsa&quot;,
        pic: &quot;https://randomuser.me/api/portraits/women/1.jpg&quot;
    },
    andrew: {
        secret: &quot;I had a foot transplant at the age of 8.&quot;,
        accessToken: &quot;wert&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/80.jpg&quot;
    },
    melanie: {
        secret: &quot;I like the smell of my own farts.&quot;,
        accessToken: &quot;trew&quot;,
        pic: &quot;https://randomuser.me/api/portraits/women/92.jpg&quot;
    },
    bobby: {
        secret: &quot;I have lice.&quot;,
        accessToken: &quot;fess&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/50.jpg&quot;
    },
    ricky: {
        secret: &quot;There are thirteen people living in my house.&quot;,
        accessToken: &quot;xcvb&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/3.jpg&quot;
    }
}
const formBuilder = function (user) {
    return `&lt;form class=&quot;retrieve-secret&quot; data-id=&quot;${user}&quot;&gt;
    &lt;button&gt;Retrieve My Secret&lt;/button&gt;
    &lt;/form&gt;` //style=&quot;display: none&quot;
}

const htmlUserList = function (users) {
    return Object.keys(users).reduce((list, user) =&gt; `${list}&lt;li&gt;&lt;h3&gt;${user}&lt;/h3&gt;&lt;div class=&quot;user-container&quot;&gt;&lt;img src=&quot;${users[user].pic}&quot;/&gt;${formBuilder(user)}&lt;span class=&quot;secret-display&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;`, '')
}

document.querySelector(&quot;#user-list&quot;).innerHTML = htmlUserList(users);

// Ajaxy Server code
let userToken;
const fetchToken = ({ password }) =&gt; {
    return userToken = `asdfasdf${password}asdfasdf`;
}

const fetchTokens = ({ token }) =&gt; {
    return token === userToken ? Object.keys(users).reduce((list, user) =&gt; { list[user] = users[user].accessToken; return list }, {}) : '416';
}

const fetchUserSecret = ({ accessToken, userName }) =&gt; {
    // Once we have a token, we can make requests to the server with the token and get a good response.
    if (accessToken === users[userName].accessToken) {
        return users[userName].secret
    }
    else {
        return '416 or whatever'
    }
}
</code></pre><p>Needless to say (maybe), all this data <em>is</em> in the global scope and available anywhere, again, we&rsquo;re just pretending it&rsquo;s on a server. Following is the fun stuff and the main closure:</p>
<pre tabindex=0><code>const client = (password) =&gt; {
    let myToken;
    let userTokens;
    return {
        login: function () {
            myToken = fetchToken({ password });
        },
        getUserTokens: function () {
            userTokens = fetchTokens({ token: myToken })
        },
        getSecret: function (user) {
            return fetchUserSecret({ accessToken: userTokens[user], userName: user })
        }
    }
}
</code></pre><p>So, <code>client</code> is a functions that takes <code>password</code> as an argument. It returns an object with three methods embeded. Each of these methods has &ldquo;closed around&rdquo; one or more of the variables in the lexical scope, namely, <code>myToken</code>, <code>userTokens</code>, and <code>password</code>.</p>
<pre tabindex=0><code>// Wiring and fireing
document.querySelector(&quot;#login-form&quot;).addEventListener(&quot;submit&quot;, function (e) {
    e.preventDefault();
    const myClient = client(e.target.login.value);
    myClient.login();
    myClient.getUserTokens();
    document.querySelectorAll(&quot;.retrieve-secret&quot;).forEach((element) =&gt; {
        element.querySelector('button').style.display = &quot;block&quot;;
        // element.style.display = 'none';
        element.addEventListener(&quot;submit&quot;, (e) =&gt; {
            e.preventDefault();
            element.parentNode.querySelector('.secret-display').innerText = myClient.getSecret(e.target.dataset.id)
        })
    })
})
</code></pre><p>Putting it together, we instantiate a client named <code>myClient</code> using the <code>client</code> function, passing in the password from the form.</p>
<pre tabindex=0><code>const myClient = client(e.target.login.value);
</code></pre><p>We log the user in, which &ldquo;fills in&rdquo; <code>myToken</code>.</p>
<pre tabindex=0><code>myClient.login();
</code></pre><p><code>myToken</code> is then used to fetch the <code>userTokens</code></p>
<pre tabindex=0><code>myClient.getUserTokens();
</code></pre><p>Then, when we click the particular users show secret button, we use that user&rsquo;s <code>accessToken</code> to fetch their secret</p>
<pre tabindex=0><code>myClient.getSecret(e.target.dataset.id)
// the method signature here is:
getSecret: function (user) {
    return fetchUserSecret({ accessToken: userTokens[user], userName: user })
}
</code></pre><p>There you have it, data privacy. And sure, the example is contrived, and defintely misses the point that this is most useful as a way to build applications, not implement secret management, but it was fun none-the-less. Thanks for hanging! The code is all <a href=https://github.com/claytron5000/closure-experiment>here</a></p>
<hr>
<p>After a good night&rsquo;s sleep, I realized this example is getting close to a real interface I might build. While the list of users' tokens is contrived, a custom fetch client wrapper, that encapsulates some of the implementation details is actually a usable idea.</p>
<p>Let&rsquo;s build a fetch wrapper for an interaction with an imagined JWT API endpoint. The goal is a custom fetch implementation that encapsulates the complexity of JWT authorization and re-authorization and allows developers to implement the <code>fetchClient</code> without having to recreate the JWT interactions.</p>
<p>I&rsquo;m using a couple imaginary modules here, one that decodes JWT tokens, checks expiration, etc. The other calls to the authorization endpoint to fetch a new token. Both of these are non-trivial, and might include there own encapsulation, but for this exercise I&rsquo;m hand-waving them.</p>
<pre tabindex=0><code>const fetchClient = (username, password) =&gt; {

    const userPass = { username, password }
    const expirationManager = (jwt) =&gt; {
        return ImaginatyJwtModule.isExpiry(jwt) ? TokenFetcher(userPass) : jwt;
    }

    let currentToken = TokenFetcher(userPass)

    return {
        get: function(endpoint) {
            // Since we're assuming the JWT token has an `exp` on it we can check for // expiration before calling back to the server, saving us a trip.
            const token = expirationManager(currentToken);
            fetch(endpoint, { token, method: 'GET' }).then(res =&gt; res.json())
        },
        post: function(endpoint, payload) {
            const token = expirationManager(currentToken);
            fetch(endpoint, { token, method: 'POST', ...payload }).then(res =&gt; res.json())
        }
    }
    
}
</code></pre><p>This could then be implemented like this:</p>
<pre tabindex=0><code>const myClientFetch = clientFetch(username, password);
// ... later on...
myClient.get('/awesome/enpoint');
</code></pre><p>The <code>clientFetch</code> function is probably too high level to actually use <code>fetch</code> directly. We could encapsulate a lower-level <code>fetch</code> that would do the default POST request stuff that&rsquo;s repetative, and easy to forget: <code>{method, mode, cors, cache, etc.}</code>. These smaller encapsulated functions become easier to test, and can be composed into high-level functionality&mldr; but that&rsquo;s a story for another day.</p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://claytron5000.github.io>
&copy; My New Hugo Site 2021
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>