<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Exploring Closures | My New Hugo Site</title>
<link rel=stylesheet href=/hugo-blog/css/style.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link rel=canonical href=https://claytron5000.github.io/hugo-blog/exploring-closures/>
<meta name=msapplication-TileColor content="#da532c">
<meta name=theme-color content="#ffffff">
</head>
<body>
<section class=section>
<div class=container>
<nav id=nav-main class=nav>
<div id=nav-name class=nav-left>
<a id=nav-anchor class=nav-item href=https://claytron5000.github.io/hugo-blog>
<h1 id=nav-heading class="title is-4">My New Hugo Site</h1>
</a>
</div>
<div class=nav-right>
<nav id=nav-items class="nav-item level is-mobile"></nav>
</div>
</nav>
<nav class=nav>
</nav>
</div>
<script src=/js/navicon-shift.js></script>
</section>
<section class=section>
<div class=container>
<div class="subtitle tags is-6 is-pulled-right">
</div>
<h2 class="subtitle is-6">April 19, 2019</h2>
<h1 class=title>Exploring Closures</h1>
<div class=content>
<p>I was inspired by Eric Elliot&rsquo;s post on closures. He posted on twitter with this super simple example <code>const secret = msg => () => msg;</code>. Here&rsquo;s the article, as usual I&rsquo;ll encourage you to read that first: <a href=https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36>https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36</a></p>
<p>The long and short is that the automatic lexical closure in javascript allows us to give us data privacy, this can be compared to protected or private properties in OOP.</p>
<p>Note: In the following example <strong>I&rsquo;m missing the main point!</strong>, which is &ldquo;Data privacy is an essential property that helps us program to an interface, not an implementation.&rdquo; What follows is a rather silly <em>implmentation</em> using data privacy to hide secret values, not create an interface to be extended and built upon later. Most of these posts and side-projects are about playing and learning, so I&rsquo;m excusing myself to do just that. (Update to this at the bottom.)</p>
<p>The application I build here is a list of &ldquo;users&rdquo;, their names and pictures can be accessed by anyone. However, their &ldquo;secrets&rdquo; are accessible only by making a request with the corresponding <code>accessToken</code>. Here&rsquo;s an example user:</p>
<pre tabindex=0><code>{
    jimmy: {
        secret: &quot;I eat cat food&quot;,
        accessToken: &quot;fdsasaf&quot;
    }
}
</code></pre><p>I&rsquo;m keying the object on the name for convenience.</p>
<p>In order to get the <code>accessToken</code> we need to send a password, which then returns a token, that token can then be used to get a list of <code>accessTokens</code> for each of the other users.</p>
<p>In this whole process we want to keep our password, our token, and our list of tokens out of the global scope, and not saved to any external source (say session storage). This is where our closure comes into play.</p>
<p>Note: instead of creating a real server I&rsquo;ve basically added another js file to the page. In this file is both the secret data, some page rendering, and some mocked <code>fetch</code> functions we can use to pretend we&rsquo;re calling to a server.</p>
<pre tabindex=0><code>// Page rendery server code
const users = {
    jimmy: {
        secret: &quot;I just want to be alone.&quot;,
        accessToken: &quot;l;kj&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/9.jpg&quot;
    },
    susy: {
        secret: &quot;I eat fourteen bananas every day.&quot;,
        accessToken: &quot;fdsa&quot;,
        pic: &quot;https://randomuser.me/api/portraits/women/1.jpg&quot;
    },
    andrew: {
        secret: &quot;I had a foot transplant at the age of 8.&quot;,
        accessToken: &quot;wert&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/80.jpg&quot;
    },
    melanie: {
        secret: &quot;I like the smell of my own farts.&quot;,
        accessToken: &quot;trew&quot;,
        pic: &quot;https://randomuser.me/api/portraits/women/92.jpg&quot;
    },
    bobby: {
        secret: &quot;I have lice.&quot;,
        accessToken: &quot;fess&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/50.jpg&quot;
    },
    ricky: {
        secret: &quot;There are thirteen people living in my house.&quot;,
        accessToken: &quot;xcvb&quot;,
        pic: &quot;https://randomuser.me/api/portraits/men/3.jpg&quot;
    }
}
const formBuilder = function (user) {
    return `&lt;form class=&quot;retrieve-secret&quot; data-id=&quot;${user}&quot;&gt;
    &lt;button&gt;Retrieve My Secret&lt;/button&gt;
    &lt;/form&gt;` //style=&quot;display: none&quot;
}

const htmlUserList = function (users) {
    return Object.keys(users).reduce((list, user) =&gt; `${list}&lt;li&gt;&lt;h3&gt;${user}&lt;/h3&gt;&lt;div class=&quot;user-container&quot;&gt;&lt;img src=&quot;${users[user].pic}&quot;/&gt;${formBuilder(user)}&lt;span class=&quot;secret-display&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/li&gt;`, '')
}

document.querySelector(&quot;#user-list&quot;).innerHTML = htmlUserList(users);

// Ajaxy Server code
let userToken;
const fetchToken = ({ password }) =&gt; {
    return userToken = `asdfasdf${password}asdfasdf`;
}

const fetchTokens = ({ token }) =&gt; {
    return token === userToken ? Object.keys(users).reduce((list, user) =&gt; { list[user] = users[user].accessToken; return list }, {}) : '416';
}

const fetchUserSecret = ({ accessToken, userName }) =&gt; {
    // Once we have a token, we can make requests to the server with the token and get a good response.
    if (accessToken === users[userName].accessToken) {
        return users[userName].secret
    }
    else {
        return '416 or whatever'
    }
}
</code></pre><p>Needless to say (maybe), all this data <em>is</em> in the global scope and available anywhere, again, we&rsquo;re just pretending it&rsquo;s on a server. Following is the fun stuff and the main closure:</p>
<pre tabindex=0><code>const client = (password) =&gt; {
    let myToken;
    let userTokens;
    return {
        login: function () {
            myToken = fetchToken({ password });
        },
        getUserTokens: function () {
            userTokens = fetchTokens({ token: myToken })
        },
        getSecret: function (user) {
            return fetchUserSecret({ accessToken: userTokens[user], userName: user })
        }
    }
}
</code></pre><p>So, <code>client</code> is a functions that takes <code>password</code> as an argument. It returns an object with three methods embeded. Each of these methods has &ldquo;closed around&rdquo; one or more of the variables in the lexical scope, namely, <code>myToken</code>, <code>userTokens</code>, and <code>password</code>.</p>
<pre tabindex=0><code>// Wiring and fireing
document.querySelector(&quot;#login-form&quot;).addEventListener(&quot;submit&quot;, function (e) {
    e.preventDefault();
    const myClient = client(e.target.login.value);
    myClient.login();
    myClient.getUserTokens();
    document.querySelectorAll(&quot;.retrieve-secret&quot;).forEach((element) =&gt; {
        element.querySelector('button').style.display = &quot;block&quot;;
        // element.style.display = 'none';
        element.addEventListener(&quot;submit&quot;, (e) =&gt; {
            e.preventDefault();
            element.parentNode.querySelector('.secret-display').innerText = myClient.getSecret(e.target.dataset.id)
        })
    })
})
</code></pre><p>Putting it together, we instantiate a client named <code>myClient</code> using the <code>client</code> function, passing in the password from the form.</p>
<pre tabindex=0><code>const myClient = client(e.target.login.value);
</code></pre><p>We log the user in, which &ldquo;fills in&rdquo; <code>myToken</code>.</p>
<pre tabindex=0><code>myClient.login();
</code></pre><p><code>myToken</code> is then used to fetch the <code>userTokens</code></p>
<pre tabindex=0><code>myClient.getUserTokens();
</code></pre><p>Then, when we click the particular users show secret button, we use that user&rsquo;s <code>accessToken</code> to fetch their secret</p>
<pre tabindex=0><code>myClient.getSecret(e.target.dataset.id)
// the method signature here is:
getSecret: function (user) {
    return fetchUserSecret({ accessToken: userTokens[user], userName: user })
}
</code></pre><p>There you have it, data privacy. And sure, the example is contrived, and defintely misses the point that this is most useful as a way to build applications, not implement secret management, but it was fun none-the-less. Thanks for hanging! The code is all <a href=https://github.com/claytron5000/closure-experiment>here</a></p>
<hr>
<p>After a good night&rsquo;s sleep, I realized this example is getting close to a real interface I might build. While the list of users' tokens is contrived, a custom fetch client wrapper, that encapsulates some of the implementation details is actually a usable idea.</p>
<p>Let&rsquo;s build a fetch wrapper for an interaction with an imagined JWT API endpoint. The goal is a custom fetch implementation that encapsulates the complexity of JWT authorization and re-authorization and allows developers to implement the <code>fetchClient</code> without having to recreate the JWT interactions.</p>
<p>I&rsquo;m using a couple imaginary modules here, one that decodes JWT tokens, checks expiration, etc. The other calls to the authorization endpoint to fetch a new token. Both of these are non-trivial, and might include there own encapsulation, but for this exercise I&rsquo;m hand-waving them.</p>
<pre tabindex=0><code>const fetchClient = (username, password) =&gt; {

    const userPass = { username, password }
    const expirationManager = (jwt) =&gt; {
        return ImaginatyJwtModule.isExpiry(jwt) ? TokenFetcher(userPass) : jwt;
    }

    let currentToken = TokenFetcher(userPass)

    return {
        get: function(endpoint) {
            // Since we're assuming the JWT token has an `exp` on it we can check for // expiration before calling back to the server, saving us a trip.
            const token = expirationManager(currentToken);
            fetch(endpoint, { token, method: 'GET' }).then(res =&gt; res.json())
        },
        post: function(endpoint, payload) {
            const token = expirationManager(currentToken);
            fetch(endpoint, { token, method: 'POST', ...payload }).then(res =&gt; res.json())
        }
    }
    
}
</code></pre><p>This could then be implemented like this:</p>
<pre tabindex=0><code>const myClientFetch = clientFetch(username, password);
// ... later on...
myClient.get('/awesome/enpoint');
</code></pre><p>The <code>clientFetch</code> function is probably too high level to actually use <code>fetch</code> directly. We could encapsulate a lower-level <code>fetch</code> that would do the default POST request stuff that&rsquo;s repetative, and easy to forget: <code>{method, mode, cors, cache, etc.}</code>. These smaller encapsulated functions become easier to test, and can be composed into high-level functionality&mldr; but that&rsquo;s a story for another day.</p>
</div>
</div>
</section>
<section class=section>
<div class="container has-text-centered">
<p></p>
</div>
</section>
</body>
</html>