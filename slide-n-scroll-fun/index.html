<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Slide 'n Scroll fun | My New Hugo Site</title>
<link rel=stylesheet href=/hugo-blog/css/style.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5>
<link rel=canonical href=https://claytron5000.github.io/hugo-blog/slide-n-scroll-fun/>
<meta name=msapplication-TileColor content="#da532c">
<meta name=theme-color content="#ffffff">
</head>
<body>
<section class=section>
<div class=container>
<nav id=nav-main class=nav>
<div id=nav-name class=nav-left>
<a id=nav-anchor class=nav-item href=https://claytron5000.github.io/hugo-blog>
<h1 id=nav-heading class="title is-4">My New Hugo Site</h1>
</a>
</div>
<div class=nav-right>
<nav id=nav-items class="nav-item level is-mobile"></nav>
</div>
</nav>
<nav class=nav>
</nav>
</div>
<script src=/js/navicon-shift.js></script>
</section>
<section class=section>
<div class=container>
<div class="subtitle tags is-6 is-pulled-right">
</div>
<h2 class="subtitle is-6">March 8, 2017</h2>
<h1 class=title>Slide 'n Scroll fun</h1>
<div class=content>
<p>I was tasked with creating a scroll animation, something that I’ve done before, but in a very ad-hoc fashion. I think the first time I did a “parallax” style scroll I did something like this:</p>
<p>That worked fine on an overpowered PC and when it was moving a tiny image up and off the page, but the next task was to move an image across the page in response to scrolling, and I wanted to make sure it was performant on all devices.</p>
<p>The first step was to avoid using `top` or `left` to define the image position. Paul Irish and Paul Lewis have a canonical<a href=https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/> post</a> on this. The quick take away is the least “expensive” properties to animate are transform, scale, rotate and opacity. For this example we’ll use opacity.</p>
<p>The entire premise of this post is that I’m making performant animations. There is a legitimate question whether this level of detail was premature optimization. However, I had some time and wanted to make the most butter-smooth animations I could.</p>
<p>The second issue was to use the broadly supported <a href=https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame>requestAnimationFrame</a>(rAF). This allows us to make an animation change(frame), only when the computer will actually change pixels on the screen. Otherwise you could end up with repaints occurring whenever and a resulting jumpy animation.</p>
<p>Finally, I incorporated Paul Lewis’s debounce on the rAF <a href=https://www.html5rocks.com/en/tutorials/speed/animations/>post</a>. Basically this is using the rAF to separate the scroll event from the animation update, and prevent the browser from stacking up rAF calls.</p>
<p>Above is the basic skeleton that I took from Paul Lewis. One thing he does that I didn’t get around to is he separates reflows from adding classes. If the animation shows signs of jitters or performance slow-downs in the real-world this is something I might re-address.</p>
<h2 id=scroll-end>Scroll End</h2>
<p>Part of the animation requested was to add a “jiggle” or “wobble” to the image when scrolling stopped. It turns out there is no “scrollEnd” event, so we have to find it ourselves. My solution involved the High Resolution Timestamp.</p>
<p>First I added a timeCheck variable outside the update function. Then I set the timeCheck variable to equal the timestamp at the bottom of the update function.</p>
<p>This way on my second(or third or fourth..) time through update(), we can compare the difference between the time the animation starts, and the last time through. This should give us a pretty accurate idea if we’ve stopped scrolling or not</p>
<p>Why 17? Well, this is optimized for screens that are painting at 60fps(frames per second). Since 1 / 60 = 16.7 that’s the lowest possible time between two frames. It would be interesting to see if a slower screen, say 30fps, would trigger the added class even while continuing to scroll.</p>
<h2 id=some-math>Some Math</h2>
<p>Finally, I wanted to define the movement of the image based on both scrolling, width of the image, and height of the screen. For a while I struggled to figure out the math, and through sheer will I came up with an algorithm that worked. But then the designer looked at it and decided he wanted the movement to start and stop a little differently.</p>
<p>Stumped, I took a walk. I knew there was some easy way to solve for a two variable problem… Somewhere on the walk I realized that was I was doing was defining a line.</p>
<p>This took many hours</p>
<p>Once I’d figure that out, I could dig deep in my memories of Highschool and drudge up the old</p>
<p>from Algebra. For those of you rusty m is the slope of the line (rise over run) and b is where the line intersects the y axis. From there I just had to define where the image was at page bottom, and where it was at page top, then draw a line between two corners and figure out the slope. (If you look closely you can see my line in the illustration is significantly off, ie. it doesn’t intersect the correct parts of the image rectangle.)</p>
<p>This looks a little ugly because there’s some maths to get the position of the bottom corner of the image. But it’s essentially just filling in the values for m and b and solving for x.</p>
<p>Here’s some math figuring out the Right to Left version. And trust me there were pages and pages more of this crap, this is the cleaned up version.</p>
<p>That pencil is so naturally placed</p>
<p>Here’s the full code. I’m not sure how much use it is since there are specific problems I’ve solved here.</p>
</div>
</div>
</section>
<section class=section>
<div class="container has-text-centered">
<p></p>
</div>
</section>
</body>
</html>